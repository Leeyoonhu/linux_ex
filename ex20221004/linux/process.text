** 프로세스 관리 명령 (ps) ** => chapter 10

* 터미널에서 실행시킨 프로세스 상세 정보 출력 : ps a, ps u
    - 상태 문자 설명
    USER = 계정 명
    %CPU = CPU 사용량 
    %MEM = 메모리 사용량
    VSZ = 가상 메모리 크기 (kB)
    RSS = 사용중인 물리적 메모리 크기 (kB)
    START = 프로세스 시작 시간



* 전체 프로세스 목록 (UNIX option) : ps -e | ps -f
    ex) ps -e | more (시스템에 실행 중인 모든 프로세스 출력)
    ex) ps -ef | more (모든 프로세스에 대한 자세한 정보 출력)


* 전체 프로세스 목록 출력하기 (BSD option) : ps ax | ps axu
    ex) ps ax | more (시스템에 실행 중인 모든 프로세스 출력)
    ex) ps axu | more (모든 프로세스에 대한 자세한 정보 출력)


* 특정 사용자의 프로세스 목록 출력 : ps -u 특정 사용자, 자세히 보기 ps -fu (반드시 u가 f뒤에 와야함)
    ex) ps -u user1
    ex) ps -fu user1


* 특정 프로세스 정보 출력하기 : ps -p PID / ps -fp PID (f가 붙으면 더 자세히)
    ex) ps -p 1234
    ex) ps -fp 1234


* 특정 프로세스 정보 검색하기 : ps와 grep 활용, " ps -ef | grep 명령 " 의 형태
    ex) ps -ef | grep bash


* 특정 프로세스 정보 검색하기 : pgrep (패턴과 일치한 프로세스 정보 출력)
    - 형식 pgrep [option]
    ex) pgrep -x bash : bash 패턴을 지정하여, PID 검색
    ex) pgrep -l bash : bash 패턴을 지정하여, PID와 명령 명 검색
    ex) ps -fp $(pgrep -x bash) : pgrep과 ps 명령을 연결하면 자세한 정보 검색 가능
    ex) ps -fp $(pgrep -u user1 bash) : -u 옵션으로 사용자명을 지정하여, 해당 사용자의 프로세스 정보만 검색


* 시그널 (56 가지)
    - 프로세스에 무언가 발생했음을 알리는 메세지
    - 무엇이 발생했는지 나타내는 미리 정의된 상수 사용
    - 시그널은 번호로 구분되고, 이름을 가지고 있음
    - 시그널 받은 프로세스는 기본적으로 종료
    ex) kill -l 명령어로 조회 가능

* 시그널 종류
    - SIGHUP (1) : 종료 : 터미널과 연결이 끊겼을 경우
    - SIGINT (2) : 종료 : interupt로 사용자가 ctrl+c 를 입력하면 발생
    - SIGQUIT (3) : 
    - SIGKILL (9) : 종료 : 강제종료


* 프로세스 종료하기 : kill [PID]
    - 기능 : 지정한 시그널을 프로세스에 보냄
    - 형식 : kill [-시그널] PID
    - 2: 인터럽트 시그널 보냄
    - 9: 프로세스 강제 종료
    - 15: 프로세스 관련 파일 정리 후 종료, 종료되지 않은 프로세스가 잇을 수 있음

    ex) kill 1001
    ex) kill -9 ~
    ex) kill -15 ~

    예제 )) man ps 로 창을 키고, 다른 터미널에서 ps -fp $(pgrep -x man)을 검색후, 해당 kill PID 하기(강제 종료)
    1번 터미널 ) $ man ps 
    2번 터미널 ) $ ps -fp $(pgrep -x man) --> PID 5863으로 검색됨
    2번 터미널 ) $ kill 5863
    1번 터미널 ) "종료됨" 문구 출력


* 프로세스 종료하기 : pkill [CMD]
    - PID가 아닌 CMD 로 프로세스를 찾아 종료
    - 위와 동일한 예제 진행

    예제 )) man ps 로 창을 키고, 다른 터미널에서 ps -fp $(pgrep -x man)을 검색후, 해당 kill PID 하기(강제 종료)
    1번 터미널 ) $ man ps 
    2번 터미널 ) $ ps -fp $(pgrep -x man) --> PID 5863으로 검색되나 cmd로 죽일것임
    2번 터미널 ) $ sudo pkill man 
    1번 터미널 ) "종료됨" 문구 출력


* 프로세스 종료하기 : killall
    - pkill과 같이 프로세스의 명령 이름 (CMD) 로 프로세스를 찾아 종료
    - 해당 이름으로 실행중인 모든 프로세스 종료됨




** 포 그라운드, 백 그라운드 작업과 작업 제어 **

* 포 그라운드 작업(프로세스)
    - 사용자가 입력한 명령이 실행되어 결과가 출력될 때 까지 기다리는 방식
    ex) $ sleep 20 => 해당 터미널을 20초간 대기시킴

* 백 그라운드 작업(프로세스)
    - 명령을 실행하면 처리가 끝나는 것과 관계없이 곧바로 프롬프트가 출력되어 사용자가 다른 작업을 계속 진행할 수 있음
    - 한 터미널에서 여러개의 프로세스 동시 실행 가능
    - 명령을 백 그라운드로 실행하려면 명령의 마지막에 &(앰퍼샌드) 기호 추가
    - 실행 시 프롬프트가 바로 나옴
    ex) $ sleep 20 & => 백그라운드 작업, 프롬프트가 바로 나와 다른 명령 실행가능
    ex) $ find / -name passwd > pw.dat 2>&1 & => pw.dat에 결과와 오류 둘다 저장하겠다

* jobs 명령 실행 예 
    - 작업 번호 []  : 백그라운드 실행 시 마다 순차적으로 증가
    - 작업 순서 : 
        + : 가장 최근에 접근한 작업
        - : + 작업 바로 전에 접근한 작업
        공백 : 그 외의 작업
    - 상태 : 
        실행중 : 실행 중
        완료 : 작업이 정상적으로 종료
        종료됨 : 작업이 비정상적으로 종료
        멈춤 : 작업이 잠시 중단
    - 명령 :
        ex) sleep 100 & 백그라운드로 실행 중인 명령


- 작업 전환하기 
    - ctrl + z : 잠시 중단 (멈춤)
    - bg %[Number] : jobs 에서의 해당 Number를 포 그라운드 -> 백 그라운드로 전환
    - fg : 현재 백 그라운드 -> 포 그라운드로 전환

    ex) 포 그라운드 -> 백 그라운드 전환
        $ jobs -> 현재 작업 있는지 확인
        $ sleep 100 -> 포 그라운드 작업 실행
        ^z -> ctrl + z 로 멈춤 
        $ jobs -> [1]+ 멈춤     sleep 100
        $ bg %1 -> jobs 에서 1번을 백그라운드로 전환
        $ jobs -> [1]+ 실행중   sleep 100 &

    ex) 백 그라운드 -> 포 그라운드 전환
        $ sleep 100 & -> [1] PID
        $ jobs -> [1]+ 실행중       sleep 100 &
        $ fg -> sleep 100 


- 작업 종료하기
    - ctrl + c : 작업 종료
    - PID 검색 후 kill PID 로 강제 종료
    - 백 그라운드 작업은 kill 명령으로 강제 종료 : kill %작업번호

    ex) ctrl + c로 작업 종료하기
        $ sleep 100 -> 포 그라운드 작업
        ^C -> ctrl + c 로 강제종료
        
    ex) kill %작업번호로 작업 종료하기
        $ sleep 100 & -> 백 그라운드 작업 
        $ kill %1 -> 작업 번호 1번 강제종료
        $ jobs -> [1]+ 종료됨   


        

    